/* 
 * Copyright (c) 2016 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc.team2084.CMonster2016.subsystems;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;

import org.usfirst.frc.team2084.CMonster2016.RobotMap;
import org.usfirst.frc.team2084.CMonster2016.RollingAverage;
import org.usfirst.frc.team2084.CMonster2016.parameters.Parameter;
import org.usfirst.frc.team2084.CMonster2016.parameters.Parameter.Type;
import org.usfirst.frc.team2084.CMonster2016.parameters.ParameterBundle;

import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.CANTalon.FeedbackDevice;
import edu.wpi.first.wpilibj.CANTalon.FeedbackDeviceStatus;
import edu.wpi.first.wpilibj.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * Subsystem that controls the arm, but not the shooter.
 * 
 * @author Ben Wolsieffer
 */
@Parameter(key = ArmSubsystem.P_KEY, type = Type.NUMBER, numberValue = ArmSubsystem.DEFAULT_P)
@Parameter(key = ArmSubsystem.I_KEY, type = Type.NUMBER, numberValue = ArmSubsystem.DEFAULT_I)
@Parameter(key = ArmSubsystem.D_KEY, type = Type.NUMBER, numberValue = ArmSubsystem.DEFAULT_D)
@Parameter(key = ArmSubsystem.I_ZONE_KEY, type = Type.NUMBER, numberValue = ArmSubsystem.DEFAULT_I_ZONE)
@Parameter(key = ArmSubsystem.ANGLE_TOLERANCE_KEY, type = Type.NUMBER,
        numberValue = ArmSubsystem.DEFAULT_ANGLE_TOLERANCE) // degrees
public class ArmSubsystem extends Subsystem {

    public static final String P_KEY = "p";
    public static final String I_KEY = "i";
    public static final String D_KEY = "d";
    public static final String I_ZONE_KEY = "i_zone";
    public static final String ANGLE_TOLERANCE_KEY = "angle_tolerance";

    public static final double DEFAULT_P = 0.02;
    public static final double DEFAULT_I = 0.0001;
    public static final double DEFAULT_D = 0.0;
    public static final double DEFAULT_I_ZONE = 20000;
    public static final double DEFAULT_ANGLE_TOLERANCE = 0.6;

    public static final File ARM_ANGLE_PROPERTIES_FILE = new File("arm-angle.properties");
    public static final String ARM_ANGLE_KEY = "arm_angle";
    public static final double DEFAULT_ARM_ANGLE = Math.toRadians(65);

    private final Properties armAngleProperties = new Properties();

    /**
     * Number of revolutions that cause one inch of movement of the lead screw.
     */
    public static final double REVS_PER_INCH = 32;

    /**
     * Distance from the pivot point to the top attachment point for the lifting
     * linkage.
     */
    public static final double ARM_ATTACHMENT_POINT = 8.3125;

    /**
     * Length of the linkage bar that connects the slider to the arm.
     */
    public static final double LIFTING_BAR_LENGTH = 13.625;

    /**
     * Vertical distance from slider to arm pivot.
     */
    public static final double PIVOT_POINT_HEIGHT = 5;

    /**
     * Lead screw position when the arm is lowered.
     */
    public static final double ARM_HOME_POSITION = angleToRevs(0);

    /**
     * Maximum allowable arm angle. This is currently enforced in the software,
     * but it could be moved to the Talon SRX.
     */
    public static final double ARM_MAX_ANGLE = Math.toRadians(65);

    public static final double ARM_MAX_POSITION = ARM_HOME_POSITION;
    public static final double ARM_MIN_POSITION = 5 * REVS_PER_INCH;

    public static final double RAMP_RATE = 0;

    public static double angleTolerance;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    public static final double DOWN_ANGLE = 0;
    public static final double COLLECT_ANGLE = Math.toRadians(12);
    public static final double AIM_ANGLE = Math.toRadians(30);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon leftTalon = RobotMap.armSubsystemLeftTalon;
    private final CANTalon rightTalon = RobotMap.armSubsystemRightTalon;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private final RollingAverage averageError = new RollingAverage(10);

    public ArmSubsystem() {
        ParameterBundle<ArmSubsystem> parameters = new ParameterBundle<>("Arm Subsystem", ArmSubsystem.class);
        leftTalon.setFeedbackDevice(FeedbackDevice.CtreMagEncoder_Relative);
        rightTalon.setFeedbackDevice(FeedbackDevice.CtreMagEncoder_Relative);

        leftTalon.setForwardSoftLimit(ARM_MIN_POSITION);

        rightTalon.setForwardSoftLimit(ARM_MIN_POSITION);

        leftTalon.enableLimitSwitch(true, true);
        rightTalon.enableLimitSwitch(true, true);

        // Make sure soft limits are disabled, or annoying behavior results,
        // because the Talon saves its state between power cycles
        setLimitsEnabled(false);

        setBrakeEnabled(true);

        parameters.addListener((key, type, val) -> {
            switch (key) {
            case ANGLE_TOLERANCE_KEY:
                angleTolerance = Math.toRadians((Double) val);
            break;
            default:
                double p = parameters.getNumber(P_KEY);
                double i = parameters.getNumber(I_KEY);
                double d = parameters.getNumber(D_KEY);
                int iZone = (int) parameters.getNumber(I_ZONE_KEY);
                leftTalon.setPID(p, i, d, 0, iZone, RAMP_RATE, 0);
                rightTalon.setPID(p, i, d, 0, iZone, RAMP_RATE, 0);
            break;
            }
        });

        leftTalon.setSafetyEnabled(false);
        rightTalon.setSafetyEnabled(false);

        leftTalon.reverseOutput(true);
        rightTalon.reverseOutput(true);

        try {
            armAngleProperties.load(new FileInputStream(ARM_ANGLE_PROPERTIES_FILE));
            setMeasuredArmAngle(getSavedArmAngle());
        } catch (IOException e) {
            System.err.println("Warning: could not load arm angle, make sure to manually override:\n" + e);
        }

        // Check for sensors
        if (leftTalon.isSensorPresent(
                FeedbackDevice.CtreMagEncoder_Relative) != FeedbackDeviceStatus.FeedbackStatusPresent) {
            DriverStation.reportError("Error: left arm encoder cannot be found", false);
        }
        if (rightTalon.isSensorPresent(
                FeedbackDevice.CtreMagEncoder_Relative) != FeedbackDeviceStatus.FeedbackStatusPresent) {
            DriverStation.reportError("Error: right arm encoder cannot be found", false);
        }
    }

    /**
     * Sets the output power of the arm.
     * 
     * @param speed the speed, between -1.0 and 1.0
     */
    public void setSpeed(double speed) {
        setLeftSpeed(speed);
        setRightSpeed(speed);
    }

    public void setLeftSpeed(double speed) {
        leftTalon.changeControlMode(TalonControlMode.PercentVbus);
        leftTalon.set(speed);
    }

    public void setRightSpeed(double speed) {
        rightTalon.changeControlMode(TalonControlMode.PercentVbus);
        rightTalon.set(speed);
    }

    private double setpoint = 0;

    /**
     * Sets the angle of the arm to the specified value. This must be called
     * repeatedly to update the average error.
     * 
     * @param angle the angle in radians
     */
    public void setAngle(double angle) {
        // Make sure the arm does not get over-extended. The Talons can do this
        // but I never got it working.
        if (angle > ARM_MAX_ANGLE) {
            angle = ARM_MAX_ANGLE;
        }

        leftTalon.changeControlMode(TalonControlMode.Position);
        rightTalon.changeControlMode(TalonControlMode.Position);

        setpoint = angle;
        double revs = angleToRevs(angle);

        double error = getError();
        averageError.newValue(Math.abs(error));
        SmartDashboard.putNumber("angle error", error);
        SmartDashboard.putNumber("average angle error", getAverageError());

        leftTalon.set(revs);
        rightTalon.set(revs);

    }

    /**
     * Resets the rolling average error to the current error.
     */
    public void resetAverageError() {
        averageError.reset(Math.abs(getError()));
    }

    /**
     * Gets whether the arm is at its target angle.
     * 
     * @return true if the average error is less than {@link #ANGLE_TOLERANCE}
     */
    public boolean onTarget() {
        return getAverageError() < angleTolerance;
    }

    /**
     * Stops the arm's motion.
     */
    public void stop() {
        setSpeed(0);
    }

    /**
     * Gets the difference between the setpoint and the current angle.
     * 
     * @return the error in radians
     */
    public double getError() {
        return getAngle() - setpoint;
    }

    /**
     * Gets the rolling average of the error in the arm's angle.
     * 
     * @return the average error in radians
     */
    public double getAverageError() {
        return averageError.getAverage();
    }

    /**
     * Gets the current angle of the arm. This is based on the average angle of
     * both sides.
     * 
     * @return the current angle in radians
     */
    public double getAngle() {
        return revsToAngle((leftTalon.getPosition() + rightTalon.getPosition()) / 2);
    }

    /**
     * Enables or disables the brake mode of the motor controllers for the arm.
     * 
     * @param enabled if true, enable brake mode
     */
    public void setBrakeEnabled(boolean enabled) {
        leftTalon.enableBrakeMode(enabled);
        rightTalon.enableBrakeMode(enabled);
    }

    public double getSavedArmAngle() {
        String angleString = armAngleProperties.getProperty(ARM_ANGLE_KEY, Double.toString(DEFAULT_ARM_ANGLE));
        try {
            double angle = Double.parseDouble(angleString);
            return angle;
        } catch (NumberFormatException ex) {
            System.err.println("Warning: could not parse saved arm angle, make sure to manually override.");
        }
        return DEFAULT_ARM_ANGLE;
    }

    public void saveArmAngle() {
        armAngleProperties.setProperty(ARM_ANGLE_KEY, Double.toString(getAngle()));
        try {
            ARM_ANGLE_PROPERTIES_FILE.createNewFile();
            armAngleProperties.store(new FileOutputStream(ARM_ANGLE_PROPERTIES_FILE),
                    "Persistent storage of arm angle");
        } catch (IOException e) {
            System.err.println("Warning: could not save arm angle:\n" + e);
        }
    }

    /**
     * Converts the revolutions of the motor to the corresponding arm angle.
     * Fewer revolutions mean a larger angle.
     * 
     * @param revs the number of revolutions
     * @return the angle of the arm
     */
    private static double revsToAngle(double revs) {
        // Moves 1 inch every 32 rotations (16:1 gearbox + 0.5" per rev lead
        // screw)
        double d = revs / REVS_PER_INCH;

        // Distance from pivot to slide attachment
        double c = Math.sqrt(PIVOT_POINT_HEIGHT * PIVOT_POINT_HEIGHT + d * d);
        double theta = Math.atan(d / PIVOT_POINT_HEIGHT);
        double angle = Math
                .acos((ARM_ATTACHMENT_POINT * ARM_ATTACHMENT_POINT - (LIFTING_BAR_LENGTH * LIFTING_BAR_LENGTH) + c * c)
                        / (2 * ARM_ATTACHMENT_POINT * c));

        return (angle + theta) - (Math.PI / 2);
    }

    /**
     * Converts an angle to its corresponding number of motor revolutions.
     * 
     * @param angle the angle in radians
     * @return the number of revolutions
     */
    private static double angleToRevs(double angle) {

        double kh = ARM_ATTACHMENT_POINT * Math.sin(angle) + PIVOT_POINT_HEIGHT;

        double d =
                Math.sqrt(LIFTING_BAR_LENGTH * LIFTING_BAR_LENGTH - kh * kh) + ARM_ATTACHMENT_POINT * Math.cos(angle);

        return d * REVS_PER_INCH;
    }

    public void setMeasuredArmAngle(double angle) {
        double revs = angleToRevs(angle);
        leftTalon.setPosition(revs);
        rightTalon.setPosition(revs);
    }

    /**
     * Resets the angle of the arm to 0.
     */
    public void resetAngle() {
        leftTalon.setPosition(ARM_HOME_POSITION);
        rightTalon.setPosition(ARM_HOME_POSITION);
    }

    /**
     * Enables or disables the software limits of the Talons.
     * 
     * @param enabled if true, enable the limits
     */
    public void setLimitsEnabled(boolean enabled) {
        leftTalon.enableForwardSoftLimit(enabled);
        leftTalon.enableReverseSoftLimit(enabled);
        rightTalon.enableForwardSoftLimit(enabled);
        rightTalon.enableReverseSoftLimit(enabled);
    }

    @Override
    public void initDefaultCommand() {
    }
}
