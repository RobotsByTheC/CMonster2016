/* 
 * Copyright (c) 2015 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc.team2084.CMonster2015.commands;

import org.usfirst.frc.team2084.CMonster2015.Robot;
import org.usfirst.frc.team2084.CMonster2015.RobotMap;
import org.usfirst.frc.team2084.CMonster2015.drive.processors.LinearRamper;
import org.usfirst.frc.team2084.CMonster2015.drive.processors.LinearRamper.Type;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * Drives the robot at the specified x and y speeds and heading for a certain
 * amount of time.
 */
public class DriveHeadingCommand extends RotateToCommand {

    public static final double RAMP_RATE = 1.0;

    public static final String X_KEY = "X";
    public static final String Y_KEY = "Y";
    public static final String DRIVE_TIME_KEY = "Drive Time";
    public static final String TIMEOUT_KEY = "Timeout";

    /**
     * The {@link LinearRamper} that ramps the x speed;
     */
    private final LinearRamper xRamper = new LinearRamper(RAMP_RATE, Type.UP);
    /**
     * The {@link LinearRamper} that ramps the y speed;
     */
    private final LinearRamper yRamper = new LinearRamper(RAMP_RATE, Type.UP);

    /**
     * The speed to drive in the x direction.
     */
    private double x;
    /**
     * The speed to drive in the y direction.
     */
    private double y;
    /**
     * The amount of time to drive.
     */
    private double driveTime;

    /**
     * Creates a {@link DriveHeadingCommand} that does nothing for a second.
     * This is mostly here to provide defaults for the parameters.
     */
    public DriveHeadingCommand() {
        this(0.0, 0.0, 1.0, 0.0, 1.0, 2.0);
    }

    /**
     * Drives the robot at the specified x and y speeds and heading for a
     * certain amount of time, while also limiting the max rotation speed.
     * 
     * @param x the x speed
     * @param y the y speed
     * @param heading the heading
     * @param time the amount of time to drive
     */
    public DriveHeadingCommand(double x, double y, double driveTime, double heading,
            double maxRotationSpeed, double timeout) {
        this(x, y, heading, driveTime, maxRotationSpeed, timeout, false);
    }

    /**
     * Drives the robot at the specified x and y speeds and heading for a
     * certain amount of time, while also limiting the max rotation speed. This
     * can also optionally print out the heading error to the SmartDashboard.
     * 
     * @param x the x speed
     * @param y the y speed
     * @param heading the heading
     * @param time the amount of time to drive
     * @param debug whether to print the heading error
     */
    public DriveHeadingCommand(double x, double y, double driveTime, double heading,
            double maxRotationSpeed, double timeout, boolean debug) {
        super(heading, maxRotationSpeed, timeout, debug);

        addNumberParameter(X_KEY, x);
        addNumberParameter(Y_KEY, y);
        addNumberParameter(DRIVE_TIME_KEY, driveTime);
        addNumberParameter(TIMEOUT_KEY, timeout);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveSubsystem);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    /**
     * Update parameter values and reset rampers.
     */
    @Override
    protected void initialize() {
        super.initialize();

        x = getNumberParameter(X_KEY);
        y = getNumberParameter(Y_KEY);
        driveTime = getNumberParameter(DRIVE_TIME_KEY);
        setTimeout(getNumberParameter(TIMEOUT_KEY));

        xRamper.reset();
        yRamper.reset();
    }

    /**
     * Drives the robot to the specified location and heading.
     */
    @Override
    protected void execute() {
        double dX = xRamper.process(x);
        double dY = yRamper.process(y);

        // If the drive time expired, stop driving.
        if (timeSinceInitialized() > driveTime) {
            dX = 0;
            dY = 0;
        }
        RobotMap.driveSubsystemMecanumDriveAlgorithm.driveFieldHeadingCartesian(dX, dY, heading,
                rotationRamper.process(maxRotationSpeed));
        if (debug) {
            SmartDashboard.putNumber(HEADING_ERROR_KEY,
                    RobotMap.driveSubsystemMecanumDriveAlgorithm.getHeadingError());
        }
    }
}
