/* 
 * Copyright (c) 2015 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc.team2084.CMonster2015.subsystems;

import org.usfirst.frc.team2084.CMonster2015.RobotMap;

import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.MotorSafety;
import edu.wpi.first.wpilibj.MotorSafetyHelper;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 * The subsystem that controls the tote lifter (and its air recycling system
 * [Recycle Rush!]), the gate and the ejector. Circuit diagrams for the air
 * recycling system are available on the the team shared Google Drive folder.
 */
public class ToteLifterSubsystem extends Subsystem {

    public static final int EJECTOR_TALON_PDP_CHANNEL = 15;
    public static final double EJECTOR_TALON_EXTENED_CURRENT_THRESHOLD = 15;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Solenoid raiseSolenoid = RobotMap.toteLifterSubsystemRaiseSolenoid;
    DoubleSolenoid storageSolenoid = RobotMap.toteLifterSubsystemStorageSolenoid;
    Solenoid lowerVentSolenoid = RobotMap.toteLifterSubsystemLowerVentSolenoid;
    Solenoid gateSolenoid = RobotMap.toteLifterSubsystemGateSolenoid;
    SpeedController ejectorTalon = RobotMap.toteLifterSubsystemEjectorTalon;
    DigitalInput leftLimitSwitch = RobotMap.toteLifterSubsystemLeftLimitSwitch;
    DigitalInput rightLimitSwitch = RobotMap.toteLifterSubsystemRightLimitSwitch;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
     * The watchdog used to prevent runaway motors if the code screws up.
     */
    private final MotorSafetyHelper watchdog = new MotorSafetyHelper((MotorSafety) ejectorTalon);

    /**
     * Represents the state of the tote lifter.
     */
    public enum LifterState {
        /**
         * State where the tote lifter raises without venting the top of the
         * cylinder, providing more air for lowering.
         */
        LOW_POWER_RAISE(true, Value.kReverse, false),
        /**
         * State for raising the lifter.
         */
        RAISE(true, Value.kReverse, true),
        /**
         * State that is used to store air in the recycling system before
         * lowering.
         */
        STORE(false, Value.kForward, false),
        /**
         * State that lowers the lifter. The system needs to have stored air in
         * the recycling system for this to work.
         */
        LOWER(false, Value.kReverse, false);

        /**
         * The state of the raise (single) solenoid.
         */
        private final boolean raise;
        /**
         * The state of the storage (double) solenoid.
         */
        private final Value storage;
        /**
         * The state of the lower vent (single) solenoid.
         */
        private final boolean lowerVent;

        private LifterState(boolean raise, Value storage, boolean lowerVent) {
            this.raise = raise;
            this.storage = storage;
            this.lowerVent = lowerVent;
        }
    }

    /**
     * The state of the tote lifter.
     */
    private LifterState lifterState = LifterState.STORE;

    /**
     * Sets the state of the tote lifter to the specified value.
     * 
     * @param state the tote lifter state
     */
    public void setLifterState(LifterState state) {
        lifterState = state;
        raiseSolenoid.set(state.raise);
        storageSolenoid.set(state.storage);
        lowerVentSolenoid.set(state.lowerVent);
    }

    /**
     * Gets the state of the tote lifter.
     * 
     * @return the tote lifter state
     */
    public LifterState getLifterState() {
        return lifterState;
    }

    public boolean isLeftLifterLowered() {
        return leftLimitSwitch.get();
    }

    public boolean isRightLifterLowered() {
        return rightLimitSwitch.get();
    }

    /**
     * Represents the state of the tote gate, which prevents totes from sliding
     * out of the front of the robot.
     */
    public enum GateState {
        /**
         * State when the gate is open (lowered into the floor).
         */
        OPEN(false),
        /**
         * State when the gate is open (raised out of the floor).
         */
        CLOSED(true);

        /**
         * The state of the gate solenoid.
         */
        private final boolean value;

        private GateState(boolean value) {
            this.value = value;
        }
    }

    /**
     * The state of the gate.
     */
    private GateState gateState = GateState.OPEN;

    /**
     * Sets the state of the tote gate to the specified value.
     * 
     * @param state the state to set
     */
    public void setGateState(GateState state) {
        gateState = state;
        gateSolenoid.set(state.value);
    }

    /**
     * Gets the state of the tote gate.
     * 
     * @return the gate state
     */
    public GateState getGateState() {
        return gateState;
    }

    /**
     * Represents the state of the tote ejector.
     */
    public enum EjectorState {
        /**
         * State when the tote ejector is extending.
         */
        EXTENDING(-0.4),
        /**
         * State when the tote ejector is retracting.
         */
        RETRACTING(0.7),
        /**
         * State when the tote ejector is stopped.
         */
        STOPPED(0.0);

        /**
         * The ejector motor speed for this particular state.
         */
        private final double speed;

        private EjectorState(double speed) {
            this.speed = speed;
        }
    }

    /**
     * The state of the tote ejector.
     */
    private EjectorState ejectorState = EjectorState.STOPPED;

    /**
     * Sets the state of the tote ejector to the specified value. If
     * {@code state != EjectorState.STOPPED}, this needs to be called over and
     * over to feed the watchdog.
     * 
     * @param state the state to set
     */
    public void setEjectorState(EjectorState state, double ramping) {
        ejectorState = state;

        watchdog.setSafetyEnabled(state != EjectorState.STOPPED);
        ejectorTalon.set(state.speed * ramping);
    }

    /**
     * Gets the state of the tote ejector.
     * 
     * @return the ejector state.
     */
    public EjectorState getEjectorState() {
        return ejectorState;
    }

    /**
     * Gets whether the tote ejector is extended. This was supposed to work off
     * a limit switch, that never happened, so we wanted to use a current
     * threshold, but that didn't work either.
     * 
     * @return false
     */
    public boolean isEjectorExtended() {
        return false;
        // return Robot.pdp.getCurrent(EJECTOR_TALON_PDP_CHANNEL) >
        // EJECTOR_TALON_EXTENED_CURRENT_THRESHOLD;
        // return ejectorExtendedLimitSwitch.get();
    }

    /**
     * Gets whether the tote ejector is retracted. This was supposed to work off
     * a limit switch, that never happened.
     * 
     * @return false
     */
    public boolean isEjectorRetracted() {
        return false; // ejectorRetractedLimitSwitch.get();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void initDefaultCommand() {

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    }
}
