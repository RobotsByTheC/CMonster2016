/* 
 * Copyright (c) 2015 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc.team2084.CMonster2015.commands;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;

import org.usfirst.frc.team2084.CMonster2015.Robot;
import org.usfirst.frc.team2084.CMonster2015.drive.EncoderWheelController;
import org.usfirst.frc.team2084.CMonster2015.drive.GyroMecanumDriveAlgorithm;

import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * Command that logs the rate and angle of the gyro, along with a timestamp, to
 * a file.
 * 
 * @author Ben Wolsieffer
 */
public class GyroLoggingCommand extends ParameterCommand {

    /**
     * The parameter name for the number of samples.
     */
    public static final String NUM_SAMPLES_KEY = "Gyro Log Samples";
    /**
     * The default number of samples.
     */
    public static final int DEFAULT_NUM_SAMPLES = 5000;
    /**
     * The filename to write the the log to.
     */
    public static final String LOG_FILE = "/home/lvuser/gyro-log.csv";

    /**
     * Implementation of the thread that does the logging.
     */
    private class LoggingThread implements Runnable {

        @Override
        public void run() {
            // Take a snapshot of the number of samples
            int numSamples = GyroLoggingCommand.this.numSamples;
            // Arrays to hold each column of data
            long timeLog[] = new long[numSamples];
            double headingLog[] = new double[numSamples];
            double rateLog[] = new double[numSamples];

            // Take the samples
            for (int i = 0; i < numSamples; i++) {
                // Stop if the command ended
                if (!running) {
                    break;
                }
                timeLog[i] = System.nanoTime();
                GyroMecanumDriveAlgorithm<EncoderWheelController<SpeedController>> drive = Robot.driveSubsystem.getMecanumDriveAlgorithm();
                headingLog[i] = drive.getHeading();
                rateLog[i] = drive.getAngularSpeed();
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                }
            }

            // Write the data to a file
            File logFile = new File(LOG_FILE);
            try {
                logFile.createNewFile();
                try (PrintStream stream = new PrintStream(logFile)) {
                    for (int i = 0; i < numSamples; i++) {
                        // Stop if the command ended
                        if (!running) {
                            break;
                        }
                        stream.println(timeLog[i] + "," + headingLog[i] + "," + rateLog[i]);
                    }
                }
            } catch (IOException e) {
                System.err.println("Unable to create log file: " + LOG_FILE);
            }
        }
    }

    private volatile boolean running = false;
    private int numSamples;
    private Thread loggingThread;

    /**
     * Creates a {@link GyroLoggingCommand} that logs
     * {@link #DEFAULT_NUM_SAMPLES} samples.
     */
    public GyroLoggingCommand() {
        this(DEFAULT_NUM_SAMPLES);
    }

    /**
     * Creates a {@link GyroLoggingCommand} that logs the specified number of
     * samples.
     * 
     * @param numSamples the number of samples
     */
    public GyroLoggingCommand(int numSamples) {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        addNumberParameter(NUM_SAMPLES_KEY, numSamples);
    }

    /**
     * Start logging gyro data.
     */
    @Override
    protected void initialize() {
        // If the number of samples was not set in the constructor, get it from
        // the SmartDashboard
        if (numSamples < 0) {
            numSamples = (int) SmartDashboard.getNumber(NUM_SAMPLES_KEY, DEFAULT_NUM_SAMPLES);
        }

        // Start the logging thread
        running = true;
        loggingThread = new Thread(new LoggingThread());
        loggingThread.start();
    }

    /**
     * Does nothing because the actual logging is done in a separate thread.
     */
    @Override
    protected void execute() {
    }

    /**
     * Command finishes when the logging thread ends.
     */
    @Override
    protected boolean isFinished() {
        return !loggingThread.isAlive();
    }

    /**
     * Stops the logging.
     */
    @Override
    protected void end() {
        running = false;
    }

    /**
     * Stops the logging.
     */
    @Override
    protected void interrupted() {
        end();
    }
}
