/* 
 * Copyright (c) 2016 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc.team2084.CMonster2016.subsystems;

import org.usfirst.frc.team2084.CMonster2016.RobotMap;
import org.usfirst.frc.team2084.CMonster2016.RollingAverage;
import org.usfirst.frc.team2084.CMonster2016.drive.PIDConstants;

import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.CANTalon.FeedbackDevice;
import edu.wpi.first.wpilibj.CANTalon.FeedbackDeviceStatus;
import edu.wpi.first.wpilibj.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class ArmSubsystem extends Subsystem {

    public static final double REVS_PER_INCH = 32;

    public static final double ARM_ATTACHMENT_POINT = 8.3125;
    public static final double LIFTING_BAR_LENGTH = 14;
    public static final double PIVOT_POINT_HEIGHT = 5;

    public static final double ARM_HOME_POSITION = angleToRevs(0);

    public static final double ARM_MAX_POSITION = ARM_HOME_POSITION;
    public static final double ARM_MIN_POSITION = 5 * REVS_PER_INCH;

    public static final double RAMP_RATE = 0;

    public static final double ANGLE_TOLERANCE = Math.toRadians(1);

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    public static final double DOWN_ANGLE = 0;
    public static final double COLLECT_ANGLE = Math.toRadians(12);
    public static final double AIM_ANGLE = Math.toRadians(30);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    public static final PIDConstants ARM_PID_CONSTANTS = new PIDConstants(0.02, 0.00002, 0);
    public static final int ARM_I_ZONE = 100;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon leftTalon = RobotMap.armSubsystemLeftTalon;
    private final CANTalon rightTalon = RobotMap.armSubsystemRightTalon;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private final RollingAverage averageError = new RollingAverage(10);

    /**
     * 
     */
    public ArmSubsystem() {
        leftTalon.setFeedbackDevice(FeedbackDevice.CtreMagEncoder_Relative);
        rightTalon.setFeedbackDevice(FeedbackDevice.CtreMagEncoder_Relative);

        leftTalon.setForwardSoftLimit(ARM_MIN_POSITION);

        rightTalon.setForwardSoftLimit(ARM_MIN_POSITION);

        leftTalon.enableLimitSwitch(true, true);
        rightTalon.enableLimitSwitch(true, true);

        //

        setLimitsEnabled(false);

        setBrakeEnabled(true);

        setTalonPID(leftTalon, ARM_PID_CONSTANTS, ARM_I_ZONE, RAMP_RATE);
        setTalonPID(rightTalon, ARM_PID_CONSTANTS, ARM_I_ZONE, RAMP_RATE);

        leftTalon.setSafetyEnabled(false);
        rightTalon.setSafetyEnabled(false);

        leftTalon.reverseOutput(true);
        rightTalon.reverseOutput(true);

        resetAngle();

        if (leftTalon.isSensorPresent(FeedbackDevice.CtreMagEncoder_Relative) != FeedbackDeviceStatus.FeedbackStatusPresent) {
            DriverStation.reportError("Error: left arm encoder cannot be found", false);
        }
        if (rightTalon.isSensorPresent(FeedbackDevice.CtreMagEncoder_Relative) != FeedbackDeviceStatus.FeedbackStatusPresent) {
            DriverStation.reportError("Error: right arm encoder cannot be found", false);
        }
    }

    public void setSpeed(double speed) {
        leftTalon.changeControlMode(TalonControlMode.PercentVbus);
        rightTalon.changeControlMode(TalonControlMode.PercentVbus);
        rightTalon.set(speed);

        leftTalon.set(speed);
    }

    private double setpoint = 0;

    public void setAngle(double angle) {
        leftTalon.changeControlMode(TalonControlMode.Position);
        rightTalon.changeControlMode(TalonControlMode.Position);

        setpoint = angle;
        double revs = angleToRevs(angle);

        double error = getError();
        averageError.newValue(Math.abs(error));
        SmartDashboard.putNumber("angle error", error);
        SmartDashboard.putNumber("average angle error", getAverageError());

        leftTalon.set(revs);
        rightTalon.set(revs);

    }

    public void resetAverageError() {
        averageError.reset(Math.abs(getError()));
    }

    public boolean onTarget() {
        return getAverageError() < ANGLE_TOLERANCE;
    }

    public void stop() {
        setSpeed(0);
    }

    public double getError() {
        return getAngle() - setpoint;
    }

    public double getAverageError() {
        return averageError.getAverage();
    }

    public double getAngle() {
        return revsToAngle((leftTalon.getPosition() + rightTalon.getPosition()) / 2);
    }

    public void setBrakeEnabled(boolean enabled) {
        leftTalon.enableBrakeMode(enabled);
        rightTalon.enableBrakeMode(enabled);
    }

    public static void setTalonPID(CANTalon talon, PIDConstants constants, int izone, double rampRate) {
        talon.setPID(constants.p, constants.i, constants.d, constants.f, izone, rampRate, 0);
    }

    private static double revsToAngle(double revs) {
        // Moves 1 inch every 32 rotations (16:1 gearbox + 0.5" per rev lead
        // screw)
        double d = revs / REVS_PER_INCH;

        // Distance from pivot to slide attachment
        double c = Math.sqrt(PIVOT_POINT_HEIGHT * PIVOT_POINT_HEIGHT + d * d);
        double theta = Math.atan(d / PIVOT_POINT_HEIGHT);
        double angle = Math.acos((ARM_ATTACHMENT_POINT * ARM_ATTACHMENT_POINT - (LIFTING_BAR_LENGTH * LIFTING_BAR_LENGTH) + c * c) / (2 * ARM_ATTACHMENT_POINT * c));

        return (angle + theta) - (Math.PI / 2);
    }

    private static double angleToRevs(double angle) {

        double kh = ARM_ATTACHMENT_POINT * Math.sin(angle) + PIVOT_POINT_HEIGHT;

        double d = Math.sqrt(LIFTING_BAR_LENGTH * LIFTING_BAR_LENGTH - kh * kh) + ARM_ATTACHMENT_POINT * Math.cos(angle);

        return d * REVS_PER_INCH;
    }

    public void resetAngle() {
        leftTalon.setPosition(ARM_HOME_POSITION);
        rightTalon.setPosition(ARM_HOME_POSITION);
    }

    public void setLimitsEnabled(boolean enabled) {
        leftTalon.enableForwardSoftLimit(enabled);
        leftTalon.enableReverseSoftLimit(enabled);
        rightTalon.enableForwardSoftLimit(enabled);
        rightTalon.enableReverseSoftLimit(enabled);
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // setDefaultCommand(new ManualArmControl());
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
}
