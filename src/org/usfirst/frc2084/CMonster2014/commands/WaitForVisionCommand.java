/* 
 * Copyright (c) 2014 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc2084.CMonster2014.commands;

import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc2084.CMonster2014.TargetTrackingCommunication;

/**
 * This command enables vision processing on the DS laptop and waits for a
 * result. It will automatically end if it does not receive data after a certain
 * time.
 *
 * @author Ben Wolsieffer
 */
public class WaitForVisionCommand extends Command {

    /**
     * The maximum amount of time to wait for information from the vision
     * processing algorithm on the driver station laptop. Since the driving does
     * not wait for the vision in order to continue, this can be slightly higher
     * than before.
     */
    private static final double MAX_TIME = 1.5;

    public WaitForVisionCommand() {
        // Make sure the command ends after a certain amount of time
        super(MAX_TIME);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    /**
     * Initializes the vision processing on the DS laptop.
     */
    protected void initialize() {
        // Reset the goal state to unknown.
        TargetTrackingCommunication.setState(TargetTrackingCommunication.State.UNKNOWN);
        // Last ditch effort to bring the camera up on the DS laptop, probably
        // is too late.
        TargetTrackingCommunication.setCameraEnabled(true);
        // Tell the DS laptop to starting detecting the hot target.
        TargetTrackingCommunication.setAutonomousVisionRunning(true);
    }

    /**
     * This command doesn't do anything except for wait for data, so this method
     * does nothing.
     */
    protected void execute() {
    }

    /**
     * Returns true when the target state is not unknown (meaning that the DS
     * laptop reported either hot or not hot) or the timeout expired.
     *
     * @return true if the command should end
     */
    protected boolean isFinished() {
        return !TargetTrackingCommunication.getState().equals(TargetTrackingCommunication.State.UNKNOWN) || timeSinceInitialized() > MAX_TIME;
    }

    /**
     * Turns off vision processing and the camera feed on the DS laptop. This
     * saves CPU cycles on the laptop and network bandwidth.
     */
    protected void end() {
        TargetTrackingCommunication.setAutonomousVisionRunning(false);
        TargetTrackingCommunication.setCameraEnabled(false);
    }

    /**
     * This command should never be interrupted because it only runs during
     * autonomous, but call {@link #end()} to clean up just in case.
     */
    protected void interrupted() {
        end();
    }
}
