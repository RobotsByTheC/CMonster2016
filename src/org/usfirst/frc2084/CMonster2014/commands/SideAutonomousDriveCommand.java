/* 
 * Copyright (c) 2014 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc2084.CMonster2014.commands;

import edu.wpi.first.wpilibj.ADXL345_I2C;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc2084.CMonster2014.Robot;
import org.usfirst.frc2084.CMonster2014.RobotMap;

/**
 * DOES NOT WORK! DO NOT USE!
 */
public class SideAutonomousDriveCommand extends Command {

    /**
     * The speed to drive at for the first part of autonomous. The robot should
     * continue at this speed until it has reached {@link #FAST_DRIVE_DISTANCE}.
     */
    private static final double FAST_DRIVING_SPEED = 0.9;
    /**
     * The speed to drive for hitting the wall and turning.
     */
    private static final double SLOW_DRIVING_SPEED = 0.9;
    /**
     * The distance to drive while moving at {@link #FAST_DRIVING_SPEED} in
     * feet.
     */
    private static final double FAST_DRIVE_DISTANCE = 3.0;
    /**
     * The rate at which the robot should accelerate.
     */
    private static final double ACCELERATION = 1.1;
    /**
     * The G-Force threshold at which the robot should stop. This needs to be
     * calibrated.
     */
    private static final double GFORCE_LIMIT = 0.7; //SET ME!!!!
    /**
     * The orientation the robot should be in when it hits the wall in degrees.
     */
    private static final double ROTATION_SETPOINT = 90.0;
    /**
     * Maximum time this part of autonomous can take before ending
     * automatically. This is to prevent a major problem should the robot not
     * detect when it hits the wall.
     */
    private static final double TIMEOUT = 4.0;
    private double gForce = 0.0;
    private double currentSpeed = 0.0;
    private double currentAngle = 0.0;
    private boolean movingFast = true;
    private final boolean leftGoal;

    public SideAutonomousDriveCommand(boolean leftGoal) {
        super(TIMEOUT);
        this.leftGoal = leftGoal;
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveSubsystem);
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    /**
     * Called just before this {@link Command} runs the first time.
     */
    protected void initialize() {
        currentAngle = 0.0;
        currentSpeed = 0.0;
        movingFast = true;
        RobotMap.driveSubsystemRearRightEncoder.reset();
    }

    /**
     * Called repeatedly when this {@link Command} is scheduled to run.
     */
    protected void execute() {
        gForce = RobotMap.driveSubsystemAccelerometer.getAcceleration(ADXL345_I2C.Axes.kY);
        double distance = RobotMap.driveSubsystemRearRightEncoder.getDistance();
        if (movingFast) {
            if (distance < FAST_DRIVE_DISTANCE) {
                if (currentSpeed < FAST_DRIVING_SPEED) {
                    currentSpeed = timeSinceInitialized() * ACCELERATION;
                }
            } else {
                movingFast = false;
                currentSpeed = SLOW_DRIVING_SPEED;
                currentAngle = leftGoal ? -ROTATION_SETPOINT : ROTATION_SETPOINT;
            }
        }
        Robot.driveSubsystem.getMecanumDriveAlgorithm().mecanumDrive_Orientation(0, currentSpeed, currentAngle);
    }

    protected boolean isFinished() {
        return (GFORCE_LIMIT < 0 ? (gForce < GFORCE_LIMIT) : (gForce > GFORCE_LIMIT));
    }

    /**
     * Called once after {@link #isFinished()} returns true.
     */
    protected void end() {
        Robot.driveSubsystem.getMecanumDriveAlgorithm().stop();
    }

    /**
     * Called when another command which requires one or more of the same
     * subsystems is scheduled to run.
     */
    protected void interrupted() {
    }
}
